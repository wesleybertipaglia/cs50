# Sorting

## Sorting

Sorting is the process of arranging elements in a specific order. The most common order is numerical or lexicographical order. Sorting is used in many algorithms and applications. For example, sorting is used in searching algorithms, data compression, and data indexing.

There are many sorting algorithms, each with its own advantages and disadvantages. Some sorting algorithms are more efficient than others, depending on the size of the input and the distribution of the elements.

There are many types of sorting algorithms, such as:

- Bublbe Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort

## Bubble Sort

A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

**Time complexity**: O(n^2), examples:

- n = 8, 64 steps
- n = 16, 256 steps
- n = 32, 1024 steps
- n = 64, 4096 steps

## Selection Sort

A simple sorting algorithm that repeatedly selects the smallest element from the unsorted portion of the list and swaps it with the first element of the unsorted portion.

**Time complexity**: O(n^2), examples:

- n = 8, 64 steps
- n = 16, 256 steps
- n = 32, 1024 steps
- n = 64, 4096 steps

## Insertion Sort 

A simple sorting algorithm that builds the final sorted list one element at a time by inserting each element into its correct position.

**Time complexity**: O(n^2), examples:

- n = 8, 64 steps
- n = 16, 256 steps
- n = 32, 1024 steps
- n = 64, 4096 steps

## Merge Sort

A divide-and-conquer sorting algorithm that divides the list into two halves, sorts each half recursively, and then merges the sorted halves.

**Time complexity**: O(n log n), examples:

- n = 8, 24 steps
- n = 16, 64 steps
- n = 32, 160 steps
- n = 64, 384 steps

## *Quick Sort

A divide-and-conquer sorting algorithm that selects a pivot element, partitions the list into two sublists, and recursively sorts the sublists.

**Time complexity**: O(n log n), examples:

- n = 8, 24 steps
- n = 16, 64 steps
- n = 32, 160 steps
- n = 64, 384 steps

## Heap Sort

A comparison-based sorting algorithm that builds a max-heap from the list and repeatedly extracts the maximum element from the heap.

**Time complexity**: O(n log n), examples:

- n = 8, 24 steps
- n = 16, 64 steps
- n = 32, 160 steps
- n = 64, 384 steps